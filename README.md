# yanya
야!냐?

* 야냐는 하나의 프로그램 카운터(`@`)와 두 개의 레지스터(`!`,`?`)를 사용하는 난해한? 프로그래밍 언어입니다.  
* 코드가 프로그램이 읽고 쓰는 메모리 영역에 있어서 코드도 일반 데이터처럼 읽거나 (덮어)쓸 수 있고 프로그램이 실행할 코드를 프로그램 스스로가 생성하는 것도 가능합니다.  

</br>

## 예시
* Hello, World!  
```
?=28#c?>?.!=.?-35$.!,1[$1,1]Hello, World!#
```    
* 두 수 a와 b를 입력받아 a+3b를 출력
```
!=!+2.!=3>?*?!=!-2+!o!
```
* 두 수 a와 b를 입력받아 "x와 y를 인자로 받아 x+3y를 출력하는 함수(`f(x, y) = print(x + 3y)`)"를 호출
```
@=34!=!+2.!=3>?*?!=!-2+!o!@=$@#!%^i!>?i??=28.?=s@+14?=!@=4
```

<br/>

## 구성
* 야냐는 0부터 N-1까지의 값을 갖는 3개의 레지스터 `@`, `!`, `?`와 N칸의 메모리로 구성되어 있습니다. (전부 0으로 초기화)
* 야냐 프로그램을 실행하면 프로그램의 코드가 메모리의 0번부터 채워집니다. (코드의 길이는 N을 넘을 수 없습니다.)
* `@`레지스터가 가리키는 곳에 있는 명령어가 현재 실행할 명령어입니다. (x가 y를 가리킨다는 표현은 메모리 상에서 y의 주소가 x라는 의미입니다.)
* 각 명령어는 자신이 차지한 길이만큼 `@`값을 증가시켜 다음 명령어의 첫 글자를 가리키게 합니다.
* `@`이 가리킨 곳의 값이 0일 경우 종료합니다.
* `!`와 `?`는 자유롭게 사용할 수 있는 범용 레지스터입니다. `!`와 `?`에 담긴 값은 주소일 수도 있고 아닐 수도 있습니다.
* 0보다 작은 값이나 N이상의 값은 mod N 된 값으로 변환됩니다.

<br/>

## 문법 
숫자와 문자 사이 변환은 아스키 코드를 따릅니다.
* `>`, `<` : 뒤에 반드시 `!`나 `?`가 옵니다. 해당 레지스터의 값을 1증가/감소(메모리를 가리키고 있는 포인터로 봤을 때 가리키고 있는 위치를 오른쪽/왼쪽으로 한 칸 이동)시킵니다.
* `i`, `o`, `c` : 뒤에 반드시 `!`나 `?`가 옵니다.
  * `i` : 사용자로부터 숫자를 입력받아 해당 레지스터가 가리키는 메모리 공간에 씁니다. 입력받는 숫자는 0에서 N-1사이 범위에 있어야 합니다.
  * `o` : 해당 레지스터가 가리키는 메모리 공간에 들어있는 값을 숫자로 출력합니다.
  * `c` : 해당 레지스터가 가리키는 메모리 공간에 들어있는 값을 문자로 출력합니다.
* `+`, `-`, `*`, `/`, `%`, `&`, `|`, `^` : 뒤에 반드시 `!`나 `?`가 옵니다. `!`가 가리키는 곳에 있는 값과 `?`가 가리키는 곳에 있는 값을 해당 연산자에 맞는 연산을 하고 결과값을 해당 레지스터가 가리키는 곳에 씁니다. 연산자는 c언어에서 사용하는 연산자와 동일합니다.  
  ex) `-!`의 경우 `.! = .! - .?` (해당 레지스터가 앞쪽 항에 놓입니다.)  
* `@=`, `!=`, `?=` : 뒤에 오는 `"값"`을 해당 레지스터에 씁니다.
* `.!=`, `.?=` : 뒤에 오는 다음 세 가지 중 하나를 해당 레지스터가 가리키는 메모리 공간에 쓰거나 그 메모리 공간을 시작으로 하여 그 뒤로 이어서 씁니다. 레지스터 앞에 `.`을 붙이는 경우 그 레지스터가 가리키고 있는 메모리 공간(에 있는 값)을 나타냅니다.
  * `"  "` : 큰 따옴표(") 안의 내용을 있는 그대로 씁니다. ex) `"Aa10"`의 경우 [65][97][49][48] 로 쓰여짐
  * `s"값"` : 메모리에 저장되어 있던 값을 문자열로 바꿉니다. ex) `?`레지스터가 10일때 `s?`의 경우 [49][48]로
  * `"값"` : 후술
* `$"값",위치` : conditional jump입니다. `$` 뒤에는 `"값"`이 오고 `,` 뒤에 점프할 위치가 옵니다. `"값"`이 0이 아닐때 점프합니다. 점프할 위치는 '숫자'가 앞에 오고 뒤에 `[`, `]`, `~` 중 하나가 옵니다.
  * `[`, `]` : 메모리 안의 모든 `#` 중에서 현재 위치 기준으로 '숫자'만큼 앞/뒤에 있는 `#`으로 점프합니다.  
     ex) `aaa#bbbb#cc2[ddd1]eee#f#gggg` 와 같은 경우 `2[`는 `a`와 `b`사이의 `#`을, `1]`는 `e`와 `f`사이의 `#`을 의미합니다.
  * `~` : 프로그램의 맨 앞에서부터 순서대로 '숫자'번째의 `#`으로 점프합니다.
* `#` : conditional jump할 위치를 나타내는 마커입니다. 아무 일도 하지 않고 다음 명령어로 이동합니다.
* `"값"`은 다음 중 하나입니다. 소괄호는 문법의 요소가 아니고 설명을 위해 사용되었습니다.
	* (`.!` 혹은 `.?`) : 해당 레지스터가 현재 가리키는 곳의 값입니다.
  * (`.!` 혹은 `.?`)(`+` 혹은 `-`) (`"값"`) : 해당 레지스터가 현재 가리키는 곳의 값에 재귀적으로 계산된 `"값"`을 더하거나 뺍니다.
  * (`!` 혹은 `?` 혹은 `@`) : 해당 레지스터의 값입니다.
  * (`!` 혹은 `?` 혹은 `@`)(`+` 혹은 `-`)(`"값"`) : 해당 레지스터의 값에 재귀적으로 계산된 `"값"`을 더하거나 뺍니다.
  * `r` : 임의의 0부터 N-1사이의 수입니다.
  * 숫자 : 숫자입니다.

* `"값"`은 그 자체로 명령어는 아닙니다
* `"값"`을 계산할 때 제외하면 명령어의 시작 위치에서 어디까지가 한 명령어인지 알기 쉽습니다.(시작 위치에서 코드를 읽어나갈 때 어느 위치에서 끊어야하는지를 이미 읽은 코드를 다시 참조하지 않고도 알 수 있습니다.)
* 한 줄로 쓰면 복잡해보이지만 짧은 명령어들로 나눌 수 있습니다.
```
?=28#c?>?.!=.?-35$.!,1[$1,1]Hello, World!#
위의 Hello, World! 코드를 명령어 단위로 자른 뒤 각 명령어의 시작 주소를 함께 표시하면 아래와 같습니다.

주소:명령어
 0 : ?=28               //!=0 ?=28 .!='?' .?='H' // '?'=63, 'H'=72, '#'=35
 4 : #           ←──┐   //!=0 ?=28 .!='?' .?='H'
 5 : c?             │   //!=0 ?=28 .!='?' .?='H'
 7 : >?             │   //!=0 ?=29 .!='?' .?='H' print("%c", .?)
 9 : .!=.?-35       │   //!=0 ?=28 .!='H'-35 .?='H'
17 : $.!,1[      ───┘   //.!인 'H'-35가 0이 아니면(.?가 35가 아니면) 이전 #인 4번 주소로 점프
23 : $1,1]       ───┐   //무조건 41번 주소로 점프
28 : Hello, World!  │
41 : #           ←──┘
```
* ~~Brainfuck에서 출발하긴 했는데 심볼 8개만 다른 키워드로 바꾸는건 식상하고 다른거 해보고 싶었음~~  
* ~~특수문자를 최대한 많이 사용하고 싶어서 키보드의 거의 모든 특수문자에 기능을 할당함~~  

<br/>

## 기타
* 코드 파일의 확장자는 .yn을 사용하지만 필수적이진 않습니다.
* make로 컴파일해서 `./yanya code.yn`처럼 파일 이름을 실행 시 인자로 넘겨주면 실행됩니다.(인터프리터, )
* 내부 메모리와 레지스터를 시각화 하는 기능을 추가 예정.
* 언어의 스펙은 언제든지 바뀔 수 있습니다.
